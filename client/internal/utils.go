package utils

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/base64"
	"errors"
	"io"
)

const (
	smtpServer     = "smtp.example.com"
	smtpPort       = "587"
	smtpUsername   = "noreply@example.com" // Your email address
	smtpPassword   = "yourpassword"        // Your email password
	senderEmail    = "noreply@example.com" // Sender email
)

// SendAlert sends an email alert to both the system admin and ransomguard company
func SendAlert(customerEmail, companyEmail, modifiedFile string) {
	subject := "RansomGuard Alert: Honeypot File Modified!"
	body := fmt.Sprintf("Alert: The following honeypot file has been modified: %s", modifiedFile)

	// Prepare email
	message := fmt.Sprintf("Subject: %s\n\n%s", subject, body)
	recipients := []string{customerEmail, companyEmail}
	err := sendEmail(recipients, message)
	if err != nil {
		log.Printf("Failed to send alert email: %v", err)
		return
	}
	log.Printf("Alert email sent to: %s, %s", customerEmail, companyEmail)
}

// sendEmail sends an email to the recipients using the provided message body
func sendEmail(recipients []string, message string) error {
	auth := smtp.PlainAuth("", smtpUsername, smtpPassword, smtpServer)

	// Join recipients into a single string
	to := strings.Join(recipients, ", ")

	// Send email
	err := smtp.SendMail(fmt.Sprintf("%s:%s", smtpServer, smtpPort), auth, senderEmail, recipients, []byte(message))
	if err != nil {
		return fmt.Errorf("failed to send email: %v", err)
	}
	return nil
}

// EncryptData encrypts the given data using a hardcoded key
func EncryptData(data []byte, key string) ([]byte, error) {
	block, err := aes.NewCipher([]byte(key))
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	nonce := make([]byte, gcm.NonceSize())
	if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, err
	}

	encryptedData := gcm.Seal(nonce, nonce, data, nil)
	return []byte(base64.StdEncoding.EncodeToString(encryptedData)), nil
}

// DecryptData decrypts the given encrypted data using the hardcoded key
func DecryptData(encryptedData []byte, key string) ([]byte, error) {
	data, err := base64.StdEncoding.DecodeString(string(encryptedData))
	if err != nil {
		return nil, err
	}

	block, err := aes.NewCipher([]byte(key))
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	nonceSize := gcm.NonceSize()
	if len(data) < nonceSize {
		return nil, errors.New("ciphertext too short")
	}

	nonce, ciphertext := data[:nonceSize], data[nonceSize:]
	return gcm.Open(nil, nonce, ciphertext, nil)
}
// Config represents the configuration structure for ransomguard.
type Config struct {
	HoneypotFiles      []HoneypotFileConfig `json:"honeypot_files"`
	CustomerEmail      string                `json:"customer_email"`
	CompanyEmail       string                `json:"company_email"`
	RollbackWant       bool                  `json:"rollbackwant"`
	RollbackMethod     string                `json:"rollback_method"`
	RollbackVariables  map[string]string     `json:"rollback_variables"`
	StaticFileKeywords []string              `json:"static_file_keywords"`
	SecureProcesses    []string              `json:"secure_processes"`
	UnsecureAPICalls   []string              `json:"unsecure_api_calls"`
}

// HoneypotFileConfig represents the configuration for a honeypot file.
type HoneypotFileConfig struct {
	Name     string   `json:"name"`
	Extensions []string `json:"extensions"`
	Volume   string   `json:"volume"`
	Route    string   `json:"route"`
}

// Alert represents an alert generated by the ransomguard.
type Alert struct {
	Description string
	ProcessName string
	ProcessID   int
}

// LoadConfig loads the configuration from an encrypted file.
func LoadConfig() (*Config, error) {
	// Simulating the loading of a configuration file.
	// You would replace this with your actual loading and decryption logic.
	fileContent, err := ioutil.ReadFile("config.json")
	if err != nil {
		return nil, fmt.Errorf("failed to read config file: %v", err)
	}

	var config Config
	if err := json.Unmarshal(fileContent, &config); err != nil {
		return nil, fmt.Errorf("failed to unmarshal config: %v", err)
	}

	return &config, nil
}

// TerminateProcess terminates the given process by process ID (PID).
func TerminateProcess(pid int) error {
	process, err := os.FindProcess(pid)
	if err != nil {
		return fmt.Errorf("failed to find process with PID %d: %v", pid, err)
	}

	err = process.Signal(syscall.SIGTERM)
	if err != nil {
		return fmt.Errorf("failed to terminate process with PID %d: %v", pid, err)
	}

	// Wait for a moment to allow graceful termination
	time.Sleep(2 * time.Second)
	if err = process.Signal(syscall.SIGKILL); err != nil {
		return fmt.Errorf("failed to force kill process with PID %d: %v", pid, err)
	}

	return nil
}

// QuarantineProcess moves the executable file associated with the process to a quarantine directory.
func QuarantineProcess(processName string) error {
	quarantineDir := "/var/quarantine"
	err := os.MkdirAll(quarantineDir, 0750)
	if err != nil {
		return fmt.Errorf("failed to create quarantine directory: %v", err)
	}

	processPath, err := exec.LookPath(processName)
	if err != nil {
		return fmt.Errorf("failed to find the executable path for process: %s, %v", processName, err)
	}

	quarantinePath := filepath.Join(quarantineDir, filepath.Base(processPath))

	err = os.Rename(processPath, quarantinePath)
	if err != nil {
		return fmt.Errorf("failed to move process to quarantine: %v", err)
	}

	return nil
}
