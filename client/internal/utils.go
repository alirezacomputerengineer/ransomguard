package utils

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/base64"
	"errors"
	"io"
)

// EncryptData encrypts the given data using a hardcoded key
func EncryptData(data []byte, key string) ([]byte, error) {
	block, err := aes.NewCipher([]byte(key))
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	nonce := make([]byte, gcm.NonceSize())
	if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, err
	}

	encryptedData := gcm.Seal(nonce, nonce, data, nil)
	return []byte(base64.StdEncoding.EncodeToString(encryptedData)), nil
}

// DecryptData decrypts the given encrypted data using the hardcoded key
func DecryptData(encryptedData []byte, key string) ([]byte, error) {
	data, err := base64.StdEncoding.DecodeString(string(encryptedData))
	if err != nil {
		return nil, err
	}

	block, err := aes.NewCipher([]byte(key))
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	nonceSize := gcm.NonceSize()
	if len(data) < nonceSize {
		return nil, errors.New("ciphertext too short")
	}

	nonce, ciphertext := data[:nonceSize], data[nonceSize:]
	return gcm.Open(nil, nonce, ciphertext, nil)
}
// Config represents the configuration structure for ransomguard.
type Config struct {
	HoneypotFiles      []HoneypotFileConfig `json:"honeypot_files"`
	CustomerEmail      string                `json:"customer_email"`
	CompanyEmail       string                `json:"company_email"`
	RollbackWant       bool                  `json:"rollbackwant"`
	RollbackMethod     string                `json:"rollback_method"`
	RollbackVariables  map[string]string     `json:"rollback_variables"`
	StaticFileKeywords []string              `json:"static_file_keywords"`
	SecureProcesses    []string              `json:"secure_processes"`
	UnsecureAPICalls   []string              `json:"unsecure_api_calls"`
}

// HoneypotFileConfig represents the configuration for a honeypot file.
type HoneypotFileConfig struct {
	Name     string   `json:"name"`
	Extensions []string `json:"extensions"`
	Volume   string   `json:"volume"`
	Route    string   `json:"route"`
}

// Alert represents an alert generated by the ransomguard.
type Alert struct {
	Description string
	ProcessName string
	ProcessID   int
}

// LoadConfig loads the configuration from an encrypted file.
func LoadConfig() (*Config, error) {
	// Simulating the loading of a configuration file.
	// You would replace this with your actual loading and decryption logic.
	fileContent, err := ioutil.ReadFile("config.json")
	if err != nil {
		return nil, fmt.Errorf("failed to read config file: %v", err)
	}

	var config Config
	if err := json.Unmarshal(fileContent, &config); err != nil {
		return nil, fmt.Errorf("failed to unmarshal config: %v", err)
	}

	return &config, nil
}

// SendAlertEmail sends an alert email to the system administrator and the company.
func SendAlertEmail(customerEmail, companyEmail string, alert Alert) error {
	// Simulated email sending logic.
	// You would replace this with your actual SMTP server logic.
	to := []string{customerEmail, companyEmail}
	msg := []byte(fmt.Sprintf("Subject: Ransomguard Alert\n\n%s detected on process: %s (PID: %d)", alert.Description, alert.ProcessName, alert.ProcessID))

	auth := smtp.PlainAuth("", "your-email@example.com", "your-email-password", "smtp.example.com")
	err := smtp.SendMail("smtp.example.com:587", auth, "from@example.com", to, msg)
	if err != nil {
		return fmt.Errorf("failed to send email: %v", err)
	}
	return nil
}

// TerminateProcess terminates the given process by process ID (PID).
func TerminateProcess(pid int) error {
	process, err := os.FindProcess(pid)
	if err != nil {
		return fmt.Errorf("failed to find process with PID %d: %v", pid, err)
	}

	err = process.Signal(syscall.SIGTERM)
	if err != nil {
		return fmt.Errorf("failed to terminate process with PID %d: %v", pid, err)
	}

	// Wait for a moment to allow graceful termination
	time.Sleep(2 * time.Second)
	if err = process.Signal(syscall.SIGKILL); err != nil {
		return fmt.Errorf("failed to force kill process with PID %d: %v", pid, err)
	}

	return nil
}

// QuarantineProcess moves the executable file associated with the process to a quarantine directory.
func QuarantineProcess(processName string) error {
	quarantineDir := "/var/quarantine"
	err := os.MkdirAll(quarantineDir, 0750)
	if err != nil {
		return fmt.Errorf("failed to create quarantine directory: %v", err)
	}

	processPath, err := exec.LookPath(processName)
	if err != nil {
		return fmt.Errorf("failed to find the executable path for process: %s, %v", processName, err)
	}

	quarantinePath := filepath.Join(quarantineDir, filepath.Base(processPath))

	err = os.Rename(processPath, quarantinePath)
	if err != nil {
		return fmt.Errorf("failed to move process to quarantine: %v", err)
	}

	return nil
}