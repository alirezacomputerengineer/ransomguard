package internal

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/base64"
	"errors"
	"io"
)

const encryptionKey = "hardcoded-encryption-key"       // Simple hardcoded key

// Config holds the configuration details for ransomguard
type Config struct {
	smtpServer     string `json:"smtp_server"` // "smtp.example.com"
	smtpPort       string `json:"smtp_port"` // "587"
	smtpUsername   string `json:"smtp_usr"` //"noreply@example.com" , Your email address
	smtpPassword   string `json:"smtp_pwd"` //"yourpassword" , Your email password
	senderEmail    string `json:"sender_email"` // "noreply@example.com" , Sender email
	configFile =   string `json:"config_file"` //"/usr/local/ransomguard/config.txt" , Path to config file
	HoneypotFiles        []HoneypotFile `json:"honeypot_files"`
	CustomerEmail        string         `json:"customer_email"`
	CompanyEmail         string         `json:"company_email"`
	StaticFileKeywords   []string       `json:"static_file_keywords"`
	SecureProcesses      []string       `json:"secure_processes"`
	UnsecureAPIChainCalls []string      `json:"unsecure_api_chain_calls"`
	RollbackWant         bool           `json:"rollback_want"`
	RollbackMethod       string         `json:"rollback_method"`
	RollbackParams       []string       `json:"rollback_params"`
}

// HoneypotFile represents the configuration for a honeypot file.
type HoneypotFile struct {
	Name     string   `json:"name"`
	Extension string `json:"extensions"`
	Volume   string   `json:"volume"`
	Route    string   `json:"route"`
}

// Alert represents an alert generated by the ransomguard.
type Alert struct {
	Description string
	ProcessName string
	ProcessID   int
}

// LoadConfig reads the config file, decrypts it, and unmarshals the JSON data
func LoadConfig() (*Config, error) {
	encryptedData, err := ioutil.ReadFile(configFile)
	if err != nil {
		log.Println("Config file not found.")
		return nil, errors.New("config file not found")
	}

	// Decrypt data
	decryptedData, err := DecryptData(encryptedData, encryptionKey)
	if err != nil {
		log.Println("Failed to decrypt config file.")
		return nil, errors.New("failed to decrypt config file")
	}

	// Unmarshal JSON
	var config Config
	err = json.Unmarshal(decryptedData, &config)
	if err != nil {
		log.Println("Failed to unmarshal config file.")
		return nil, errors.New("failed to parse config file")
	}

	log.Println("Configuration loaded successfully.")
	return &config, nil
}

// SaveConfig marshals and encrypts the config struct, and writes it to a file
func SaveConfig(config *Config) error {
	// Marshal to JSON
	data, err := json.Marshal(config)
	if err != nil {
		log.Println("Failed to marshal config.")
		return err
	}

	// Encrypt data
	encryptedData, err := EncryptData(data, encryptionKey)
	if err != nil {
		log.Println("Failed to encrypt config.")
		return err
	}

	// Write to file
	err = ioutil.WriteFile(configFile, encryptedData, 0644)
	if err != nil {
		log.Println("Failed to write config to file.")
		return err
	}

	log.Println("Configuration saved successfully.")
	return nil
}

// SendAlert sends an email alert to both the system admin and ransomguard company
func SendAlert(customerEmail, companyEmail, modifiedFile string) {
	subject := "RansomGuard Alert: Honeypot File Modified!"
	body := fmt.Sprintf("Alert: The following honeypot file has been modified: %s", modifiedFile)

	// Prepare email
	message := fmt.Sprintf("Subject: %s\n\n%s", subject, body)
	recipients := []string{customerEmail, companyEmail}
	err := sendEmail(recipients, message)
	if err != nil {
		log.Printf("Failed to send alert email: %v", err)
		return
	}
	log.Printf("Alert email sent to: %s, %s", customerEmail, companyEmail)
}

// sendEmail sends an email to the recipients using the provided message body
func sendEmail(recipients []string, message string) error {
	auth := smtp.PlainAuth("", smtpUsername, smtpPassword, smtpServer)

	// Join recipients into a single string
	to := strings.Join(recipients, ", ")

	// Send email
	err := smtp.SendMail(fmt.Sprintf("%s:%s", smtpServer, smtpPort), auth, senderEmail, recipients, []byte(message))
	if err != nil {
		return fmt.Errorf("failed to send email: %v", err)
	}
	return nil
}

// EncryptData encrypts the given data using a hardcoded key
func EncryptData(data []byte, key string) ([]byte, error) {
	block, err := aes.NewCipher([]byte(key))
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	nonce := make([]byte, gcm.NonceSize())
	if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, err
	}

	encryptedData := gcm.Seal(nonce, nonce, data, nil)
	return []byte(base64.StdEncoding.EncodeToString(encryptedData)), nil
}

// DecryptData decrypts the given encrypted data using the hardcoded key
func DecryptData(encryptedData []byte, key string) ([]byte, error) {
	data, err := base64.StdEncoding.DecodeString(string(encryptedData))
	if err != nil {
		return nil, err
	}

	block, err := aes.NewCipher([]byte(key))
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	nonceSize := gcm.NonceSize()
	if len(data) < nonceSize {
		return nil, errors.New("ciphertext too short")
	}

	nonce, ciphertext := data[:nonceSize], data[nonceSize:]
	return gcm.Open(nil, nonce, ciphertext, nil)
}

// getProcessDetails retrieves the name and PID of the process that modified the file
func getProcessDetails(filePath string) (string, int) {
	// You can use `lsof` to find which process is accessing the file
	cmd := exec.Command("lsof", "-t", filePath)
	output, err := cmd.Output()
	if err != nil {
		log.Printf("Error retrieving process details: %v", err)
		return "", 0
	}

	// Parse process ID from the output (assuming lsof returns one result)
	processID := 0
	fmt.Sscanf(string(output), "%d", &processID)

	// Retrieve process name using the process ID
	procPath := filepath.Join("/proc", fmt.Sprint(processID), "comm")
	processName, err := os.ReadFile(procPath)
	if err != nil {
		log.Printf("Error retrieving process name: %v", err)
		return "", processID
	}

	return string(processName), processID
}

// TerminateProcess terminates the given process by process ID (PID).
func TerminateProcess(pid int) error {
	process, err := os.FindProcess(pid)
	if err != nil {
		return fmt.Errorf("failed to find process with PID %d: %v", pid, err)
	}

	err = process.Signal(syscall.SIGTERM)
	if err != nil {
		return fmt.Errorf("failed to terminate process with PID %d: %v", pid, err)
	}

	// Wait for a moment to allow graceful termination
	time.Sleep(2 * time.Second)
	if err = process.Signal(syscall.SIGKILL); err != nil {
		return fmt.Errorf("failed to force kill process with PID %d: %v", pid, err)
	}

	return nil
}

// QuarantineProcess moves the executable file associated with the process to a quarantine directory.
func QuarantineProcess(processName string) error {
	quarantineDir := "/var/quarantine"
	err := os.MkdirAll(quarantineDir, 0750)
	if err != nil {
		return fmt.Errorf("failed to create quarantine directory: %v", err)
	}

	processPath, err := exec.LookPath(processName)
	if err != nil {
		return fmt.Errorf("failed to find the executable path for process: %s, %v", processName, err)
	}

	quarantinePath := filepath.Join(quarantineDir, filepath.Base(processPath))

	err = os.Rename(processPath, quarantinePath)
	if err != nil {
		return fmt.Errorf("failed to move process to quarantine: %v", err)
	}

	return nil
}
